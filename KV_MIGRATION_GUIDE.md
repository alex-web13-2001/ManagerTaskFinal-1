# Migration Guide: KV Storage to Prisma Models

## Overview

This guide documents the migration of custom columns and categories data from the key-value (KV) storage to dedicated Prisma database models.

## Background

Previously, the application stored two types of user-specific data in the KV store:
1. **Custom Columns** (`custom_columns:userId`) - User-defined status columns for Kanban board
2. **Categories** (`categories:userId`) - Task categories for organization

These were stored as JSON blobs in the `kv_store` table, which had limitations:
- No type safety
- No foreign key constraints
- Poor query performance
- No indexing
- Manual serialization/deserialization

## What Changed

### New Database Models

Two new Prisma models were added to `prisma/schema.prisma`:

#### CustomColumn Model
```prisma
model CustomColumn {
  id        String   @id @default(uuid())
  name      String
  color     String?
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@map("custom_columns")
}
```

#### Category Model
```prisma
model Category {
  id        String   @id @default(uuid())
  name      String
  color     String   @default("#3b82f6")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, name])
  @@index([userId])
  @@map("categories")
}
```

### Updated API Endpoints

All endpoints were updated to use Prisma instead of KV store:

#### Custom Columns Endpoints
- **GET /api/users/:userId/custom_columns**
  - Before: `kvStore.get('custom_columns:userId')`
  - After: `prisma.customColumn.findMany({ where: { userId } })`

- **POST /api/users/:userId/custom_columns**
  - Before: `kvStore.set('custom_columns:userId', columns)`
  - After: Transaction-based delete + create with `prisma.customColumn`

#### Categories Endpoints
- **GET /api/users/:userId/categories**
  - Before: `kvStore.get('categories:userId')`
  - After: `prisma.category.findMany({ where: { userId } })`

- **POST /api/users/:userId/categories**
  - Before: `kvStore.set('categories:userId', categories)`
  - After: Transaction-based delete + create with `prisma.category`

- **GET /api/projects/:projectId/categories**
  - Before: `kvStore.get('categories:ownerId')`
  - After: `prisma.category.findMany({ where: { userId: ownerId } })`

## Benefits

### 1. Type Safety
- TypeScript types automatically generated by Prisma
- Compile-time validation of data structures
- Better IDE autocomplete

### 2. Data Integrity
- Foreign key constraints ensure data consistency
- Cascade deletion when user is deleted
- Unique constraints on category names per user

### 3. Performance
- Indexed queries for faster lookups
- Efficient filtering and sorting
- Reduced serialization overhead

### 4. Query Capabilities
- Easy to add filtering, sorting, pagination
- Can use complex queries with joins
- Better support for aggregations

### 5. Maintainability
- Clear schema definition
- Automatic migrations
- Better debugging and monitoring

## Migration Steps

### For New Installations

1. **Apply Database Migration**
   ```bash
   npm run prisma:migrate
   ```
   This creates the `custom_columns` and `categories` tables.

2. **Generate Prisma Client**
   ```bash
   npm run prisma:generate
   ```
   This updates the Prisma client with new models.

3. **Start Using**
   The new endpoints are ready to use immediately.

### For Existing Installations

If you have existing data in the KV store, follow these steps:

1. **Backup Your Database**
   ```bash
   pg_dump -h localhost -U postgres taskmanager > backup.sql
   ```

2. **Apply Database Migration**
   ```bash
   npm run prisma:migrate
   ```

3. **Migrate Existing Data**
   
   **Option A: Migrate All Users**
   ```bash
   npm run migrate:kv all
   ```
   
   **Option B: Migrate Specific User**
   ```bash
   npm run migrate:kv user <userId>
   ```

4. **Verify Migration**
   Check that data was migrated correctly:
   ```bash
   # Connect to database
   psql -h localhost -U postgres -d taskmanager
   
   # Check custom columns
   SELECT * FROM custom_columns;
   
   # Check categories
   SELECT * FROM categories;
   ```

5. **Clean Up KV Store (Optional)**
   After verifying the migration was successful:
   ```bash
   npm run migrate:kv cleanup
   ```
   
   ⚠️ **Warning**: This permanently deletes custom columns and categories from KV store. Only run after verifying the migration.

## Testing

### Manual Testing

1. **Test Custom Columns**
   ```bash
   # Get custom columns
   curl -H "Authorization: Bearer <token>" \
        http://localhost:3001/api/users/<userId>/custom_columns
   
   # Save custom columns
   curl -X POST \
        -H "Authorization: Bearer <token>" \
        -H "Content-Type: application/json" \
        -d '{"columns": [{"id": "col1", "name": "To Do", "order": 0}]}' \
        http://localhost:3001/api/users/<userId>/custom_columns
   ```

2. **Test Categories**
   ```bash
   # Get categories
   curl -H "Authorization: Bearer <token>" \
        http://localhost:3001/api/users/<userId>/categories
   
   # Save categories
   curl -X POST \
        -H "Authorization: Bearer <token>" \
        -H "Content-Type: application/json" \
        -d '{"categories": [{"id": "cat1", "name": "Development", "color": "#3b82f6"}]}' \
        http://localhost:3001/api/users/<userId>/categories
   ```

### Database Verification

```sql
-- Check custom columns were created
SELECT 
  cc.id, cc.name, cc.color, cc."order", 
  u.email as user_email
FROM custom_columns cc
JOIN users u ON u.id = cc."userId"
ORDER BY cc."order";

-- Check categories were created
SELECT 
  c.id, c.name, c.color,
  u.email as user_email
FROM categories c
JOIN users u ON u.id = c."userId"
ORDER BY c.name;

-- Check foreign key constraints
SELECT 
  tc.constraint_name, 
  tc.table_name, 
  kcu.column_name,
  ccu.table_name AS foreign_table_name,
  ccu.column_name AS foreign_column_name 
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
  AND tc.table_schema = kcu.table_schema
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
  AND ccu.table_schema = tc.table_schema
WHERE tc.constraint_type = 'FOREIGN KEY' 
  AND tc.table_name IN ('custom_columns', 'categories');
```

## Rollback Plan

If you need to rollback the migration:

1. **Rollback Database Migration**
   ```bash
   npx prisma migrate resolve --rolled-back 20251112005800_add_custom_columns_and_categories
   ```

2. **Revert Code Changes**
   ```bash
   git revert <commit-hash>
   ```

3. **Restore from Backup** (if needed)
   ```bash
   psql -h localhost -U postgres -d taskmanager < backup.sql
   ```

## Troubleshooting

### Migration Script Errors

**Problem**: Migration script fails with "relation already exists"
**Solution**: The migration was already applied. Check with:
```sql
SELECT * FROM custom_columns LIMIT 1;
SELECT * FROM categories LIMIT 1;
```

**Problem**: Foreign key constraint violation
**Solution**: Ensure all users exist before running migration. Check:
```sql
SELECT DISTINCT "userId" FROM kv_store WHERE key LIKE 'custom_columns:%';
SELECT id FROM users;
```

### Data Not Migrating

**Problem**: `migrate:kv all` reports "No data found"
**Solution**: Check if data exists in KV store:
```sql
SELECT key, value FROM kv_store 
WHERE key LIKE 'custom_columns:%' OR key LIKE 'categories:%';
```

**Problem**: Duplicate key errors during migration
**Solution**: Data already migrated. Use `skipDuplicates: true` (already implemented).

## FAQ

**Q: Will this break existing functionality?**
A: No. The API endpoints remain the same, only the backend implementation changed.

**Q: Do I need to update my frontend code?**
A: No. The API responses have the same structure.

**Q: What happens to data in the KV store?**
A: It remains until you run the cleanup command. You can keep it as a backup.

**Q: Can I migrate incrementally?**
A: Yes. You can migrate user by user using `npm run migrate:kv user <userId>`.

**Q: What if a user has both KV and Prisma data?**
A: The migration script checks for existing Prisma data and skips if found.

**Q: Is the KV store still needed?**
A: Yes, but only for general-purpose key-value data. Custom columns and categories now use dedicated tables.

## Related Files

- `prisma/schema.prisma` - Database schema
- `prisma/migrations/20251112005800_add_custom_columns_and_categories/migration.sql` - SQL migration
- `src/server/index.ts` - Updated API endpoints
- `src/lib/migrateKV.ts` - Migration utility script
- `package.json` - Added `migrate:kv` script

## Support

If you encounter issues during migration:
1. Check the error message and console output
2. Verify database connection
3. Ensure Prisma client is up to date
4. Check the troubleshooting section above
5. Create an issue with error details

## Conclusion

This migration brings significant improvements to data management, type safety, and performance. All structured user data now uses proper database models with full Prisma support.
